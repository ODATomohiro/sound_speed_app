<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>音波解析</title>
<style>
  body{font-family:'Segoe UI',sans-serif;background:#f0f2f5;margin:0;padding:20px;color:#333;}
  h1{margin:0 0 16px;font-size:1.6em;color:#222;}
  h2{margin-top:0;font-size:1.1em;color:#444;}
  .card{background:#fff;border-radius:16px;box-shadow:0 2px 6px rgba(0,0,0,0.1);padding:16px 20px;margin-bottom:20px;}
  button{margin:4px;padding:6px 12px;border:none;border-radius:8px;font-size:0.9em;cursor:pointer;transition:background 0.2s;color:#fff;}
  button:disabled{background:#ccc;cursor:default;color:#fff;}
  .btn-impulse{background:#ff6a00;} .btn-impulse:hover{background:#cc5500;}
  .btn-noise{background:#28a745;} .btn-noise:hover{background:#1e7e34;}
  .btn-stop{background:#dc3545;} .btn-stop:hover{background:#a71d2a;}
  .btn-rec{background:#dc3545;} .btn-rec:hover{background:#a71d2a;}
  .btn-stoprec{background:#6c757d;} .btn-stoprec:hover{background:#565e64;}
  .btn-action{background:#1b84ff;} .btn-action:hover{background:#1059aa;}
  input[type=number]{width:80px;padding:4px 6px;border:1px solid #ccc;border-radius:6px;}
  select{padding:4px 6px;border-radius:6px;border:1px solid #ccc;}
  #waveWrap{position:relative;width:min(100%,1000px);margin-top:8px;}
  #wave{width:100%;height:240px;display:block;background:#fff;border:1px solid #ddd;border-radius:12px;}
  .marker{position:absolute;top:0;width:2px;height:240px;}
  .marker.a{background:#ff6a00}
  .marker.b{background:#1b84ff}
  canvas.spectrum{width:100%;height:200px;display:block;border:1px solid #ddd;border-radius:12px;margin-top:8px;}
  .badge{display:inline-block;margin-top:8px;background:#eef;padding:4px 8px;border-radius:8px;font-size:0.85em;color:#333;}
  .split{display:flex;justify-content:space-between;gap:30px;flex-wrap:wrap;}
  .block{flex:1;min-width:240px;}
</style>
</head>
<body>
<h1>音波解析</h1>

<div class="card split">
  <div class="block">
    <h2>1. 再生</h2>
    <div>
      <button id="btnImpulse" class="btn-impulse">インパルス</button>
      <button id="btnNoiseShort" class="btn-noise">ノイズ短</button>
      <button id="btnNoise" class="btn-noise">ノイズ連続</button>
      <button id="btnStop" class="btn-stop">停止</button>
    </div>
  </div>
  <div class="block">
    <h2>2. 録音</h2>
    <div>
      <button id="btnRec" class="btn-rec">録音開始</button>
      <button id="btnStopRec" class="btn-stoprec" disabled>録音停止</button>
    </div>
    <span id="recStatus">未録音</span>
  </div>
  <div class="block">
    <h2>3. 発音＋録音</h2>
    <label>音の種類:
      <select id="soundType">
        <option value="impulse">インパルス</option>
        <option value="noiseShort">ホワイトノイズ（短時間）</option>
      </select>
    </label>
    <div>
      <button id="btnPlayRec" class="btn-action">発音＋録音</button>
    </div>
  </div>
</div>

<div class="card">
  <h2>波形表示</h2>
  <div id="waveWrap">
    <canvas id="wave" width="1000" height="240"></canvas>
  </div>
  <div style="margin-top:6px;">
    <button id="btnZoomOut" class="btn-action" disabled>全体表示</button>
    <button id="btnResetPts" class="btn-action" disabled>測定点リセット</button>
    <span>点A: <span id="ptA">—</span> ms</span> /
    <span>点B: <span id="ptB">—</span> ms</span> /
    <span>Δt: <span id="dtMs">—</span> ms</span>
  </div>
  <div class="badge">サンプリングレート: <span id="srVal">—</span> Hz ／ 1サンプル ≈ <span id="spMsVal">—</span> ms</div>
</div>

<div class="card">
  <h2>音速計算</h2>
  <label>管長 L [m]: <input id="tubeLen" type="number" step="0.01" value="1.00"></label>
  <button id="btnCalc" class="btn-action">計算</button>
  <div style="margin-top:6px;">片道: <span id="c1">—</span> m/s ／ 往復: <span id="c2">—</span> m/s</div>
</div>

<div class="card">
  <h2>FFTスペクトル</h2>
  <button id="btnFFT" class="btn-action">スペクトル解析</button>
  <canvas id="spectrum" class="spectrum" width="1000" height="200"></canvas>
  <div style="margin-top:6px;">ピーク周波数: <span id="peaks">—</span></div>
</div>

<script>
let audioCtx=new (window.AudioContext||window.webkitAudioContext)();
let mediaStream,recorder,recChunks=[],sourceNode;
let sampleRate=audioCtx.sampleRate;
document.getElementById('srVal').textContent=sampleRate;
document.getElementById('spMsVal').textContent=(1000/sampleRate).toFixed(3);

// ===== Playback functions =====
function playImpulse(){
  stopSound();
  let buf=audioCtx.createBuffer(1,sampleRate,sampleRate);
  let d=buf.getChannelData(0);
  d[0]=1.0;  // 単一サンプルだけのインパルス
  sourceNode=audioCtx.createBufferSource();
  sourceNode.buffer=buf;
  sourceNode.connect(audioCtx.destination);
  sourceNode.start();
}

function playNoiseShort(){
  stopSound();
  let dur=0.1; // 100ms
  let buf=audioCtx.createBuffer(1,sampleRate, sampleRate*dur);
  let d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
  sourceNode=audioCtx.createBufferSource();
  sourceNode.buffer=buf;
  sourceNode.connect(audioCtx.destination);
  sourceNode.start();
  sourceNode.stop(audioCtx.currentTime+dur); // 100msで停止
}

function playNoise(){
  stopSound();
  let buf=audioCtx.createBuffer(1,sampleRate,sampleRate*2);
  let d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
  sourceNode=audioCtx.createBufferSource();
  sourceNode.buffer=buf;
  sourceNode.loop=true;
  sourceNode.connect(audioCtx.destination);
  sourceNode.start();
}
function stopSound(){ if(sourceNode){sourceNode.stop(); sourceNode.disconnect(); sourceNode=null;}}
btnImpulse.onclick=playImpulse; btnNoiseShort.onclick=playNoiseShort; btnNoise.onclick=playNoise; btnStop.onclick=stopSound;

// ===== Recording =====
async function startRecording(){
  mediaStream=await navigator.mediaDevices.getUserMedia({audio:true});
  recorder=new MediaRecorder(mediaStream);
  recChunks=[];
  recorder.ondataavailable=e=>recChunks.push(e.data);
  recorder.onstop=async ()=>{
    let blob=new Blob(recChunks); let arr=await blob.arrayBuffer();
    audioCtx.decodeAudioData(arr,buff=>{ data=buff.getChannelData(0); viewStart=0; viewEnd=data.length; drawWave(); document.getElementById('recStatus').textContent="録音完了"; });
  };
  recorder.start(); document.getElementById('recStatus').textContent="録音中…";
}
function stopRecording(){if(recorder){recorder.stop(); document.getElementById('recStatus').textContent="停止";}}
btnRec.onclick=()=>{startRecording();btnRec.disabled=true;btnStopRec.disabled=false;};
btnStopRec.onclick=()=>{stopRecording();btnRec.disabled=false;btnStopRec.disabled=true;};

// 発音＋録音（インパルス=200ms録音、ノイズ短=300ms録音）
btnPlayRec.onclick=async ()=>{
  await startRecording();
  let type=document.getElementById('soundType').value;
  if(type==="impulse"){ playImpulse(); setTimeout(stopRecording,200); }
  else { playNoiseShort(); setTimeout(stopRecording,300); }
};

// ===== Waveform + zoom + markers + FFT =====
let wave=document.getElementById('wave'); let ctx=wave.getContext('2d'); let W=wave.width,H=wave.height;
let waveWrap=document.getElementById('waveWrap');
let btnZoomOut=document.getElementById('btnZoomOut'); let btnResetPts=document.getElementById('btnResetPts');
let ptAEl=document.getElementById('ptA'); let ptBEl=document.getElementById('ptB'); let dtMsEl=document.getElementById('dtMs');
let data=new Float32Array(sampleRate*2); for(let i=0;i<data.length;i++){data[i]=Math.sin(2*Math.PI*440*i/sampleRate)*0.5;}
let viewStart=0,viewEnd=data.length;

function drawWave(){
  ctx.clearRect(0,0,W,H);
  const N=viewEnd-viewStart; const step=Math.max(1,Math.floor(N/W)); const amp=H/2;
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle='#1b84ff'; ctx.beginPath();
  for(let x=0;x<W;x++){
    const i0=viewStart+x*step; let min=1e9,max=-1e9;
    for(let k=0;k<step;k++){ const v=data[i0+k]||0; if(v<min)min=v; if(v>max)max=v;}
    ctx.moveTo(x,amp*(1-min)); ctx.lineTo(x,amp*(1-max));
  }
  ctx.stroke();
}
function clamp(x,a,b){return Math.max(a,Math.min(b,x));}
function xToIndex(x){const frac=clamp(x/W,0,1); return Math.floor(viewStart+frac*(viewEnd-viewStart));}

// zoom selection
let dragging=false,dragA=0,dragB=0;
wave.addEventListener('mousedown',e=>{dragging=true;dragA=e.offsetX;dragB=e.offsetX;drawWave();shadeSel();});
wave.addEventListener('mousemove',e=>{if(dragging){dragB=e.offsetX;drawWave();shadeSel();}});
wave.addEventListener('mouseup',e=>{
  if(!dragging)return; dragging=false;
  const a=Math.min(dragA,dragB), b=Math.max(dragA,dragB);
  if(Math.abs(b-a)>6&&data){
    const iA=xToIndex(a),iB=xToIndex(b);
    viewStart=iA; viewEnd=iB; drawWave(); btnZoomOut.disabled=false;
  }
});
function shadeSel(){const a=Math.min(dragA,dragB),b=Math.max(dragA,dragB); ctx.fillStyle='rgba(255,200,0,0.2)'; ctx.fillRect(a,0,b-a,H);}
btnZoomOut.onclick=()=>{viewStart=0;viewEnd=data.length;drawWave();btnZoomOut.disabled=true;};

// markers
let pointA=null,pointB=null;
function clearMarkers(){Array.from(document.querySelectorAll('.marker')).forEach(el=>el.remove());pointA=pointB=null;ptAEl.textContent='—';ptBEl.textContent='—';dtMsEl.textContent='—';}
btnResetPts.onclick=clearMarkers;
function placeMarker(i,x){const t_ms=(i/sampleRate)*1000; const div=document.createElement('div');
  if(pointA===null){pointA=i;div.className='marker a';ptAEl.textContent=t_ms.toFixed(3);}
  else if(pointB===null){pointB=i;div.className='marker b';ptBEl.textContent=t_ms.toFixed(3); const dt=Math.abs(pointB-pointA)/sampleRate*1000;dtMsEl.textContent=dt.toFixed(3);}
  else{clearMarkers();placeMarker(i,x);return;}
  div.style.left=Math.round(x)+'px';waveWrap.appendChild(div);btnResetPts.disabled=false;}

// speed calc
btnCalc.onclick=()=>{ if(pointA!=null&&pointB!=null){const dt=Math.abs(pointB-pointA)/sampleRate; const L=parseFloat(document.getElementById('tubeLen').value); document.getElementById('c1').textContent=(L/dt).toFixed(2); document.getElementById('c2').textContent=(2*L/dt).toFixed(2);}}

// FFT
btnFFT.onclick=()=>{
  if(!data) return; const N=Math.min(2048,viewEnd-viewStart); const seg=data.slice(viewStart,viewStart+N);
  let re=new Float32Array(N), im=new Float32Array(N);
  for(let i=0;i<N;i++){re[i]=seg[i];im[i]=0;}
  fft(re,im); let mags=[]; for(let i=0;i<N/2;i++){const mag=Math.sqrt(re[i]*re[i]+im[i]*im[i]); mags.push(mag);}
  let ctx2=document.getElementById('spectrum').getContext('2d'); ctx2.clearRect(0,0,1000,200); ctx2.beginPath(); ctx2.strokeStyle='#090';
  for(let x=0;x<1000;x++){const idx=Math.floor(x/1000*(N/2)); const y=mags[idx]; const yy=200-y/Math.max(...mags)*200; if(x==0)ctx2.moveTo(x,yy); else ctx2.lineTo(x,yy);} ctx2.stroke();
  let arr=[]; for(let i=1;i<N/2-1;i++){if(mags[i]>mags[i-1]&&mags[i]>mags[i+1]) arr.push({f:i*sampleRate/N, m:mags[i]});}
  arr.sort((a,b)=>b.m-a.m); let top=arr.slice(0,5).map(o=>o.f.toFixed(1)+"Hz"); document.getElementById('peaks').textContent=top.join(", ");
};

// naive FFT
function fft(re,im){
  const N=re.length; if(N<=1)return; let reEven=new Float32Array(N/2),imEven=new Float32Array(N/2),reOdd=new Float32Array(N/2),imOdd=new Float32Array(N/2);
  for(let i=0;i<N/2;i++){reEven[i]=re[i*2];imEven[i]=im[i*2];reOdd[i]=re[i*2+1];imOdd[i]=im[i*2+1];}
  fft(reEven,imEven); fft(reOdd,imOdd);
  for(let k=0;k<N/2;k++){const tRe=Math.cos(-2*Math.PI*k/N)*reOdd[k]-Math.sin(-2*Math.PI*k/N)*imOdd[k]; const tIm=Math.sin(-2*Math.PI*k/N)*reOdd[k]+Math.cos(-2*Math.PI*k/N)*imOdd[k]; re[k]=reEven[k]+tRe; im[k]=imEven[k]+tIm; re[k+N/2]=reEven[k]-tRe; im[k+N/2]=imEven[k]-tIm;}
}

drawWave();
</script>
</body>
</html>
