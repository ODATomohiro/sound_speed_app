<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>音速測定（超短パルス・安定版）</title>
<style>
*{box-sizing:border-box}html,body{margin:0;padding:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,'Hiragino Kaku Gothic ProN','Noto Sans JP','Meiryo',sans-serif;color:#111}
header{padding:20px 16px;background:linear-gradient(90deg,#dbeafe,#fff)}h1{margin:0;font-size:22px}p.sub{margin:4px 0 0;color:#555}
main{max-width:1120px;margin:20px auto;padding:0 12px}
.card{background:#fff;border:1px solid #e5e7eb;border-radius:16px;padding:16px 16px 10px;margin:16px 0;box-shadow:0 1px 2px rgba(0,0,0,0.05)}
h2{margin:0 0 12px;font-size:18px}
.controls{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0 4px}
button{appearance:none;border:1px solid #d1d5db;background:#0ea5e9;color:#fff;padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:700}
button.secondary{background:#fff;color:#111;border-color:#cbd5e1}
button:disabled{opacity:.55;cursor:not-allowed;background:#9ca3af;border-color:#9ca3af}
select{padding:8px;border:1px solid #d1d5db;border-radius:10px;background:#fff;max-width:100%}
.grid.two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid.three{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
.grid.four{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px}
label{display:flex;flex-direction:column;gap:6px;font-size:14px}
input[type=number], input[type=text]{padding:8px;border:1px solid #d1d5db;border-radius:10px}
input[type=range]{width:100%}
input[type=checkbox]{transform:scale(1.2);margin-right:6px}
.small{font-size:12px;color:#475569}
.status{font-size:12px;color:#334155;background:#f1f5f9;border:1px solid #e2e8f0;border-radius:10px;padding:8px 10px;display:flex;flex-wrap:wrap;gap:12px;align-items:center}
.badge{display:inline-flex;align-items:center;gap:6px;background:#e2e8f0;border:1px solid #cbd5e1;border-radius:999px;padding:4px 8px}
.canvas-wrap{position:relative}
canvas{background:#0b1020;border-radius:14px;max-width:100%;height:auto;border:1px solid #1f2937;touch-action:none}
.legend{display:flex;flex-wrap:wrap;gap:10px;font-size:12px;margin-top:6px;align-items:center}
.chip{display:inline-block;width:16px;height:8px;border-radius:999px;border:1px solid #222;vertical-align:middle;margin-right:6px}
.chip-t1{background:#22c55e}.chip-t2{background:#f97316}
.results{display:flex;gap:16px;flex-wrap:wrap;padding:8px 0;font-weight:600}
footer{padding:24px 16px;color:#6b7280;text-align:center}
kbd{padding:2px 6px;border:1px solid #cbd5e1;border-bottom-width:2px;border-radius:6px;background:#f8fafc;font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:#0b1020;color:#e2e8f0;border-radius:12px;padding:10px;white-space:pre-wrap;line-height:1.35}
@media (max-width:820px){.grid.two{grid-template-columns:1fr}.grid.three{grid-template-columns:1fr}.grid.four{grid-template-columns:1fr 1fr}}
</style>
</head>
<body>
  <header>
    <h1>音速測定（超短パルス・安定版）</h1>
    <p class="sub">ScriptProcessorのみ・出力切替は対応ブラウザのみ。50cm級の筒向けに0.1–3.0ms短パルス&自動設定。</p>
  </header>

  <main>
    <section class="card">
      <h2>1. デバイス</h2>
      <div class="status" id="devStatus"><span class="badge">未初期化</span></div>
      <div class="grid.three" style="display:grid;grid-template-columns:1.2fr 1.2fr auto;gap:10px;margin-top:10px">
        <label>マイク（入力）
          <select id="micSelect"><option>（許可後に取得）</option></select>
        </label>
        <label>スピーカー（出力）
          <select id="spkSelect"><option>（対応ブラウザのみ）</option></select>
          <span class="small" id="spkNote"></span>
        </label>
        <div class="controls">
          <button id="btnStart">① マイク開始</button>
          <button id="btnRefresh">再検出</button>
        </div>
      </div>
    </section>

    <section class="card">
      <h2>2. 発音（超短パルス）</h2>
      <div class="grid four">
        <label>発音タイプ
          <select id="pulseType">
            <option value="impulse" selected>クリック（超短パルス）</option>
            <option value="white">ホワイトノイズ（短）</option>
            <option value="chirp">チャープ（短）</option>
          </select>
        </label>
        <label>パルス長（ms, 0.1–3.0）
          <input id="pulseMs" type="range" min="0.1" max="3.0" step="0.1" value="0.8">
          <span id="pulseVal">0.8</span>
        </label>
        <label>帯域（低域カットHz）<input id="noiseLow" type="number" min="20" max="10000" step="10" value="500"></label>
        <label>帯域（高域カットHz）<input id="noiseHigh" type="number" min="1000" max="20000" step="100" value="8000"></label>
      </div>
      <div class="grid two">
        <label>出力レベル（スピーカー）
          <input id="outLevel" type="range" min="0.05" max="1.0" step="0.01" value="0.8">
          <span id="outLevelVal">0.80</span>
        </label>
        <label>録音窓(ms)
          <input id="windowMs" type="range" min="50" max="1000" step="10" value="120">
          <span id="windowVal">120</span>
        </label>
      </div>
      <div class="controls">
        <button id="btnPulse" disabled>② 発音 + 記録</button>
        <button id="btnTestBeep" disabled>発音テストのみ</button>
        <button id="btnReset" class="secondary">リセット</button>
      </div>
      <div class="small">※ クリックは短い白色ノイズに窓掛け＋HPF/LPF。耳障りと装置リンギングを抑えます。</div>
    </section>

    <section class="card">
      <h2>3. 目安と自動設定</h2>
      <div class="grid three">
        <label>管の長さ D（m）<input id="dist" type="number" step="0.01" value="0.50"></label>
        <div class="badge">往復遅延 目安：<span id="dtHint">—</span> ms（c≈343 m/s）</div>
        <label style="align-self:end;flex-direction:row;gap:8px;align-items:center;">
          <input id="autoGap" type="checkbox" checked> D から最小遅延を自動設定（0.8×往復遅延）
        </label>
      </div>
      <div class="grid three">
        <label>最小遅延(ms)
          <input id="minGapMs" type="range" min="0.1" max="50" step="0.1" value="2.5">
          <span id="minGapVal">2.5</span>
        </label>
        <label>しきい値（自動検出）
          <input id="thresh" type="range" min="0.02" max="0.6" step="0.01" value="0.12">
          <span id="threshVal">0.12</span>
        </label>
        <div class="controls" style="align-items:end">
          <button id="btnApplySuggested" class="secondary">推奨値をセット</button>
          <button id="btnAuto" disabled>自動検出</button>
        </div>
      </div>
    </section>

    <section class="card">
      <h2>4. 波形（時間軸・ズーム・パン）</h2>
      <div class="canvas-wrap">
        <canvas id="wave" width="1400" height="460"></canvas>
      </div>
      <div class="legend">
        <div><span class="chip chip-t1"></span>t1 / <span class="chip chip-t2"></span>t2（クリック→ドラッグ、ホイールでズーム、<kbd>R</kbd>でリセット）</div>
        <div>録音後の再生：
          <select id="playRate">
            <option value="1">1×</option>
            <option value="0.5">0.5×</option>
            <option value="0.25">0.25×（聞き分け用）</option>
          </select>
          <button id="btnPlay" disabled>録音波形を再生</button>
        </div>
      </div>
      <div class="grid two" style="margin-top:8px">
        <label>t1（ms）<div class="controls"><input id="t1ms" type="number" step="0.01" placeholder="例: 1.2"><button id="btnApplyT1">t1に適用</button></div></label>
        <label>t2（ms）<div class="controls"><input id="t2ms" type="number" step="0.01" placeholder="例: 4.0"><button id="btnApplyT2">t2に適用</button></div></label>
      </div>
      <div class="controls">
        <button id="btnClearMarks" disabled>マーク削除</button>
        <button id="btnZoomReset" class="secondary">ズームリセット</button>
        <button id="btnPng" disabled>PNG保存</button>
      </div>
    </section>

    <section class="card">
      <h2>5. 計算（v = 2D / Δt）</h2>
      <div class="results">
        <div>t1 = <span id="t1Val">–</span> ms</div>
        <div>t2 = <span id="t2Val">–</span> ms</div>
        <div>Δt = <span id="dtVal">–</span> ms</div>
        <div>v = <span id="vMeasured">–</span> m/s</div>
      </div>
      <div class="controls">
        <button id="btnCompute" disabled>計算</button>
        <button id="btnCsv" disabled>CSV出力</button>
      </div>
    </section>

    <section class="card">
      <h2>6. ログ</h2>
      <div id="log" class="mono" style="min-height:120px"></div>
    </section>
  </main>

  <footer>
    <small>© 2025 音速測定アプリ（超短パルス・安定版）</small>
  </footer>

<script>
// ---- helpers ----
const log = (m)=>{ const el=document.getElementById('log'); el.textContent += m + "¥¥n"; el.scrollTop = el.scrollHeight; };
const els = (ids)=>Object.fromEntries(ids.map(id=>[id,document.getElementById(id)]));
const E = els(['devStatus','micSelect','spkSelect','spkNote','btnStart','btnRefresh','pulseType','pulseMs','pulseVal','noiseLow','noiseHigh','outLevel','outLevelVal','windowMs','windowVal','btnPulse','btnTestBeep','btnReset','dist','dtHint','autoGap','minGapMs','minGapVal','thresh','threshVal','btnApplySuggested','btnAuto','wave','t1ms','t2ms','btnApplyT1','btnApplyT2','btnClearMarks','btnZoomReset','btnPng','t1Val','t2Val','dtVal','vMeasured','btnCompute','btnCsv','playRate','btnPlay']);

function bindRange(input, outSpan, fmt=(v)=>v){ const update = ()=> outSpan.textContent = fmt(Number(input.value)); input.addEventListener('input', update); update(); }
bindRange(E.pulseMs, E.pulseVal, v=>v.toFixed(1)); bindRange(E.outLevel, E.outLevelVal, v=>v.toFixed(2)); bindRange(E.windowMs, E.windowVal, v=>v.toFixed(0));
bindRange(E.minGapMs, E.minGapVal, v=>v.toFixed(1)); bindRange(E.thresh, E.threshVal, v=>v.toFixed(2));

const C = 343;

let audioCtx=null, sampleRate=48000;
let micStream=null, micNode=null, scriptNode=null, outGain=null;
let outAudio=null; // optional setSinkId route
let started=false;

let captured=new Float32Array(0), capturing=false;
let viewStart=0, viewEnd=0;
let t1Index=null, t2Index=null;
let dragState=null, lastActive='t2';

function enableAfterStart(on){
  [E.btnPulse, E.btnTestBeep, E.btnAuto, E.btnClearMarks, E.btnPng, E.btnCompute, E.btnCsv, E.btnPlay].forEach(b=>b.disabled=!on);
}

function setStatus({mics=0, spks=0, note=''}){
  E.devStatus.innerHTML = `<span class="badge">入力:${mics}</span><span class="badge">出力:${spks}</span>${note?`<span class="badge">${note}</span>`:''}`;
}

async function refreshDevices(){
  try{ const tmp=await navigator.mediaDevices.getUserMedia({audio:true}); tmp.getTracks().forEach(t=>t.stop()); }catch{}
  const devs = await navigator.mediaDevices.enumerateDevices();
  const mics=devs.filter(d=>d.kind==='audioinput'); const spks=devs.filter(d=>d.kind==='audiooutput');
  const prevMic=E.micSelect.value, prevSpk=E.spkSelect.value;
  E.micSelect.innerHTML=''; mics.forEach(d=>{ const o=document.createElement('option'); o.value=d.deviceId; o.textContent=d.label||`マイク (${d.deviceId.slice(0,6)})`; E.micSelect.appendChild(o); });
  E.spkSelect.innerHTML=''; if(spks.length){ spks.forEach(d=>{ const o=document.createElement('option'); o.value=d.deviceId; o.textContent=d.label||`スピーカー (${d.deviceId.slice(0,6)})`; E.spkSelect.appendChild(o); }); } else { const o=document.createElement('option'); o.textContent='（出力選択 未対応）'; E.spkSelect.appendChild(o); }
  if ([...E.micSelect.options].some(o=>o.value===prevMic)) E.micSelect.value=prevMic;
  if ([...E.spkSelect.options].some(o=>o.value===prevSpk)) E.spkSelect.value=prevSpk;
  setStatus({mics:mics.length, spks:spks.length, note:'再検出'});
}

async function ensureAudio(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)(); await audioCtx.resume(); sampleRate=audioCtx.sampleRate;
  outGain = audioCtx.createGain(); outGain.gain.value=Number(E.outLevel.value);
  // default route to AudioContext destination
  outGain.connect(audioCtx.destination);

  // Optional sink switch (safe: only if setSinkId exists)
  if ('setSinkId' in HTMLMediaElement.prototype){
    outAudio = new Audio(); outAudio.autoplay=true; E.spkNote.textContent='出力切替 対応';
    const dest = audioCtx.createMediaStreamDestination(); outGain.disconnect(); outGain.connect(dest); outAudio.srcObject = dest.stream;
    outAudio.play().catch(()=>{});
    E.spkSelect.addEventListener('change', async ()=>{ const id=E.spkSelect.value; if(id){ try{ await outAudio.setSinkId(id); log('setSinkId OK'); }catch(e){ log('setSinkId 失敗: '+e.message); } } });
  } else {
    E.spkNote.textContent='出力切替 非対応';
  }
  E.outLevel.addEventListener('input', ()=>{ if(outGain) outGain.gain.value=Number(E.outLevel.value); });
}

async function startMic(){
  await ensureAudio();
  await refreshDevices();
  const micId=E.micSelect.value;
  try{
    micStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: micId?{exact:micId}:undefined, echoCancellation:false, noiseSuppression:false, autoGainControl:false, channelCount:1 } });
  }catch(e){ log('getUserMedia 失敗: '+e.name+' / '+e.message); throw e; }
  micNode = audioCtx.createMediaStreamSource(micStream);
  scriptNode = audioCtx.createScriptProcessor(1024,1,1);
  scriptNode.onaudioprocess=(ev)=>{ if(!capturing) return; const input=ev.inputBuffer.getChannelData(0); const c=new Float32Array(input.length); c.set(input); const merged=new Float32Array(captured.length+c.length); merged.set(captured,0); merged.set(c,captured.length); captured=merged; };
  micNode.connect(scriptNode); scriptNode.connect(audioCtx.destination);
  started=true; enableAfterStart(true);
  log('マイク開始 OK');
}

// ---- signal generation ----
function emitPulse(){
  const type=E.pulseType.value, ms=Number(E.pulseMs.value)||0.8;
  const low=Math.max(20, Number(E.noiseLow.value)||500);
  const high=Math.max(low+100, Number(E.noiseHigh.value)||8000);
  const len=Math.max(1, Math.round(sampleRate*(ms/1000)));
  const buf=audioCtx.createBuffer(1,len,sampleRate); const d=buf.getChannelData(0);
  if (type==='impulse' || type==='white'){
    for(let i=0;i<len;i++){ d[i]=Math.random()*2-1; }
  } else { // chirp short
    const f0=low, f1=Math.min(high, Math.max(low*16, 6000)); const T=len/sampleRate;
    for (let i=0;i<len;i++){ const t=i/sampleRate; const k=Math.log(f1/f0)/T; const ph=2*Math.PI*f0*(Math.exp(k*t)-1)/k; d[i]=Math.sin(ph); }
  }
  for (let i=0;i<len;i++){ const t=i/(len-1); const w=Math.sin(Math.PI*t)**2; d[i]*=w; }
  const src = audioCtx.createBufferSource(); src.buffer=buf;
  const hpf=audioCtx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=low; hpf.Q.value=0.707;
  const lpf=audioCtx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=high; lpf.Q.value=0.707;
  src.connect(hpf).connect(lpf).connect(outGain);
  src.start();
}

function playCaptured(rate=1){
  if(!captured.length || !audioCtx) return;
  const buf=audioCtx.createBuffer(1,captured.length,sampleRate); buf.copyToChannel(captured,0,0);
  const src=audioCtx.createBufferSource(); src.buffer=buf; src.playbackRate.value=rate;
  const g=audioCtx.createGain(); g.gain.value=0.6; src.connect(g).connect(outGain); src.start();
}

// ---- capture control ----
function recordWithPulse(){
  captured=new Float32Array(0); t1Index=t2Index=null; updateAll();
  const autoWin = Math.min(1000, Math.max(50, Math.round((2*Number(E.dist.value||0.5)/C)*1000 * 3 + 50))); // 3×遅延+50ms
  const windowMs = Number(E.windowMs.value)||autoWin;
  capturing=true; emitPulse();
  setTimeout(()=>{ capturing=false; setFullView(); resizeCanvasForDPR(); drawWave(); log('録音完了: '+captured.length+' samples'); }, windowMs);
}

// ---- canvas & interactions ----
const ctx = E.wave.getContext('2d');
function resizeCanvasForDPR(){ const rect=E.wave.getBoundingClientRect(); const dpr=window.devicePixelRatio||1; const needW=Math.max(1,Math.floor(rect.width*dpr)); const needH=Math.max(1,Math.floor(rect.height*dpr)); if(E.wave.width!==needW||E.wave.height!==needH){ E.wave.width=needW; E.wave.height=needH; } ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr); }
function clientXToCanvasCssX(x){ const r=E.wave.getBoundingClientRect(); return x - r.left; }
function setFullView(){ viewStart=0; viewEnd=captured.length; }
function clampView(){ const len=captured.length, minW=Math.max(128, Math.floor(sampleRate*0.001)); if(viewStart<0) viewStart=0; if(viewEnd>len) viewEnd=len; if(viewEnd-viewStart<minW){ const mid=(viewStart+viewEnd)/2; viewStart=Math.max(0,Math.floor(mid-minW/2)); viewEnd=Math.min(len,viewStart+minW); } }
function xToIdxCss(xCss){ const W=E.wave.getBoundingClientRect().width||1; const span=(viewEnd-viewStart)||1; const frac=Math.max(0,Math.min(1,xCss/W)); return Math.round(viewStart+frac*span); }
function idxToXCss(idx){ const W=E.wave.getBoundingClientRect().width||1; const span=(viewEnd-viewStart)||1; return Math.round((idx-viewStart)*W/span); }
function msOf(i){ return (i/sampleRate)*1000; }
function niceStep(spanMs){ const arr=[0.1,0.2,0.5,1,2,5,10,20,50,100,200,500]; for(const s of arr){ if(spanMs/s<=10) return s; } return 500; }
function maxAbs(i0,i1){ let m=0; for(let i=i0;i<i1;i++){ const a=Math.abs(captured[i]||0); if(a>m)m=a; } return m; }
function drawWave(){
  resizeCanvasForDPR();
  const r=E.wave.getBoundingClientRect(), W=r.width, H=r.height;
  ctx.clearRect(0,0,W,H); ctx.fillStyle='#0b1020'; ctx.fillRect(0,0,W,H);
  const axisH=26;
  ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1; for(let y=0;y<=H-axisH;y+=50){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  const startMs=msOf(viewStart), endMs=msOf(viewEnd), spanMs=endMs-startMs, step=niceStep(spanMs);
  const firstTick=Math.ceil(startMs/step)*step; ctx.fillStyle='rgba(255,255,255,0.65)'; ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.font='12px system-ui';
  for(let t=firstTick; t<=endMs+1e-6; t+=step){ const idx=Math.round(t/1000*sampleRate); const x=idxToXCss(idx); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H-axisH); ctx.stroke(); ctx.fillText(t.toFixed(step<1?1:(step<10?1:0))+' ms', x+3, H-8); }
  if(!captured.length){ ctx.fillStyle='rgba(255,255,255,0.75)'; ctx.font='14px system-ui'; ctx.fillText('②で記録後にクリック/入力できます。',16,24); return; }
  const usableH=H-axisH, headroom=0.48, gain=usableH*headroom/Math.max(1e-6, maxAbs(viewStart,viewEnd));
  const s=viewStart,e=viewEnd,span=Math.max(1,e-s); ctx.strokeStyle='#7dd3fc'; ctx.lineWidth=1.5; ctx.beginPath();
  for(let x=0;x<W;x++){ const i0=Math.floor(s+span*x/W), i1=Math.floor(s+span*(x+1)/W); let lo=1e9,hi=-1e9; for(let i=i0;i<i1;i++){ const v=captured[i]||0; if(v<lo)lo=v; if(v>hi)hi=v; } if(lo===1e9){lo=0;hi=0;} const yLo=usableH/2 - lo*gain, yHi=usableH/2 - hi*gain; ctx.moveTo(x,yLo); ctx.lineTo(x,yHi); } ctx.stroke();
  drawMarker(t1Index,'#22c55e','t1'); drawMarker(t2Index,'#f97316','t2');
  function drawMarker(idx,color,label){ if(idx==null) return; if(idx<viewStart||idx>viewEnd) return; const x=idxToXCss(idx); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,usableH); ctx.stroke(); const ms=msOf(idx).toFixed(2); ctx.fillStyle=color; ctx.font='12px system-ui'; ctx.fillText(`${label}:${ms} ms`, x+4, 14); }
  ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.font='12px system-ui'; ctx.fillText(`表示: ${spanMs.toFixed(1)} ms  /  Fs: ${sampleRate} Hz`,16,H-8);
}

function envelope(data){ const N=data.length; const abs=new Float32Array(N); for(let i=0;i<N;i++) abs[i]=Math.abs(data[i]); const win=Math.max(8, Math.round(sampleRate*0.0006)); const env=new Float32Array(N); let sum=0; for(let i=0;i<N;i++){ sum+=abs[i]; if(i>=win) sum-=abs[i-win]; env[i]=sum/Math.min(i+1,win); } return env; }
function refinePeakNear(arr, idx, radius){ const N=arr.length; let best=idx, val=arr[idx]||0; for(let i=Math.max(0,idx-radius); i<=Math.min(N-1,idx+radius); i++){ if(arr[i]>val){ val=arr[i]; best=i; } } return best; }
function maybeSnap(idx){ if(!captured.length) return idx; const env=envelope(captured); return refinePeakNear(env, idx, Math.round(sampleRate*0.0015)); }

function placeAtIdx(idx){
  if (t1Index==null){ t1Index=maybeSnap(idx); lastActive='t1'; }
  else if (t2Index==null){ t2Index=maybeSnap(idx); lastActive='t2'; }
  else { const x=idxToXCss(idx); const d1=Math.abs(x-idxToXCss(t1Index)), d2=Math.abs(x-idxToXCss(t2Index)); if (d1<=d2){ t1Index=maybeSnap(idx); lastActive='t1'; } else { t2Index=maybeSnap(idx); lastActive='t2'; } }
  drawWave(); updateAll();
}

E.wave.addEventListener('click', (ev)=>{ if(!captured.length) return; placeAtIdx(xToIdxCss(clientXToCanvasCssX(ev.clientX))); });
E.wave.addEventListener('dblclick', (ev)=>{ if(!captured.length) return; const idx=xToIdxCss(clientXToCanvasCssX(ev.clientX)); placeAtIdx(idx); placeAtIdx(idx); });

E.wave.addEventListener('mousedown', (ev)=>{ if(!captured.length) return; const xCss=clientXToCanvasCssX(ev.clientX); const tol=6;
  const near=(()=>{ if(t1Index!=null && Math.abs(xCss-idxToXCss(t1Index))<=tol) return 't1'; if(t2Index!=null && Math.abs(xCss-idxToXCss(t2Index))<=tol) return 't2'; return null; })();
  if(near){ dragState={type:'marker',target:near}; lastActive=near; return; } dragState={type:'pan',startX:xCss,startViewStart:viewStart,startViewEnd:viewEnd}; });
window.addEventListener('mousemove', (ev)=>{ if(!dragState) return; const xCss=clientXToCanvasCssX(ev.clientX);
  if(dragState.type==='marker'){ const idx=xToIdxCss(xCss); if(dragState.target==='t1') t1Index=idx; else t2Index=idx; drawWave(); updateAll(); }
  else { const dx=xCss-dragState.startX; const W=E.wave.getBoundingClientRect().width||1; const span=dragState.startViewEnd-dragState.startViewStart; const shift=Math.round(-dx*span/W); viewStart=dragState.startViewStart+shift; viewEnd=dragState.startViewEnd+shift; clampView(); drawWave(); }});
window.addEventListener('mouseup', ()=>{ dragState=null; });
E.wave.addEventListener('wheel', (ev)=>{ if(!captured.length) return; ev.preventDefault(); const xCss=clientXToCanvasCssX(ev.clientX);
  const center=xToIdxCss(xCss); const factor=Math.exp(-ev.deltaY*0.0015); const span=viewEnd-viewStart;
  let newSpan=Math.max(Math.floor(span/factor), Math.floor(sampleRate*0.001)); const leftFrac=(center-viewStart)/span;
  viewStart=Math.round(center-newSpan*leftFrac); viewEnd=viewStart+newSpan; clampView(); drawWave(); }, {passive:false});
window.addEventListener('keydown', (ev)=>{ if(!captured.length) return; const step=ev.shiftKey?10:1;
  if(ev.key==='ArrowLeft'){ if(lastActive==='t2'&&t2Index!=null) t2Index=Math.max(0,t2Index-step); else if(t1Index!=null) t1Index=Math.max(0,t1Index-step); drawWave(); updateAll(); }
  else if(ev.key==='ArrowRight'){ if(lastActive==='t2'&&t2Index!=null) t2Index=Math.min(captured.length-1,t2Index+step); else if(t1Index!=null) t1Index=Math.min(captured.length-1,t1Index+step); drawWave(); updateAll(); }
  else if(ev.key==='r'||ev.key==='R'){ setFullView(); drawWave(); }});

// ---- detect & compute ----
function autoDetect(){
  if(!captured.length) return;
  const thresh=Number(E.thresh.value), minGapMs=Number(E.minGapMs.value), minGapSamples=Math.round(sampleRate*(minGapMs/1000));
  const N=captured.length; const env=envelope(captured);
  let t1=null; for(let i=0;i<N;i++){ if(env[i]>thresh){ t1=i; break; } }
  if(t1===null){ alert('t1が検出できません'); return; }
  let t2=null; for(let i=t1+minGapSamples;i<N;i++){ if(env[i]>thresh){ t2=i; break; } }
  if(t2===null){ alert('t2が検出できません'); return; }
  t1Index=t1; t2Index=refinePeakNear(env,t2,Math.round(sampleRate*0.0015));
  const s=Math.min(t1Index,t2Index), e=Math.max(t1Index,t2Index);
  const pad=Math.round((e-s)*0.6)+Math.round(sampleRate*0.005); viewStart=Math.max(0,s-pad); viewEnd=Math.min(captured.length,e+pad); clampView(); drawWave(); updateAll();
}

function setMarkerMs(which, ms){
  if (!captured.length || !Number.isFinite(ms)) return;
  const idx = Math.max(0, Math.min(captured.length-1, Math.round(ms/1000 * sampleRate)));
  if (which==='t1'){ t1Index = idx; lastActive='t1'; }
  else { t2Index = idx; lastActive='t2'; }
  const s=Math.min(t1Index,t2Index), e=Math.max(t1Index,t2Index); const pad=Math.round((e-s)*0.6)+Math.round(sampleRate*0.005); viewStart=Math.max(0,s-pad); viewEnd=Math.min(captured.length,e+pad); clampView(); drawWave(); updateAll();
}

function updateHintsAndAuto(){
  const D = Number(E.dist.value);
  if (!Number.isFinite(D) || D<=0){ E.dtHint.textContent='—'; return; }
  const dt = (2*D/C)*1000;
  E.dtHint.textContent = dt.toFixed(2);
  if (E.autoGap.checked){
    const mg = Math.max(0.1, dt*0.8);
    E.minGapMs.value = mg.toFixed(1);
    E.minGapVal.textContent = mg.toFixed(1);
  }
}

function updateAll(){
  const ms1 = (t1Index!=null) ? (msOf(t1Index).toFixed(2)) : '–';
  const ms2 = (t2Index!=null) ? (msOf(t2Index).toFixed(2)) : '–';
  E.t1Val.textContent = ms1; E.t2Val.textContent = ms2;
  if(t1Index==null || t2Index==null){ E.dtVal.textContent='–'; E.vMeasured.textContent='–'; return; }
  const dt = Math.abs(t2Index - t1Index) / sampleRate;
  E.dtVal.textContent = (dt*1000).toFixed(2);
  const D = Number(E.dist.value);
  E.vMeasured.textContent = (D>0 && dt>0) ? (2*D/dt).toFixed(2) : '–';
}

E.dist.addEventListener('input', ()=>{ updateHintsAndAuto(); updateAll(); });

// ---- wire UI ----
E.btnStart.addEventListener('click', async ()=>{ try{ await startMic(); }catch(e){} });
E.btnRefresh.addEventListener('click', async ()=>{ await refreshDevices(); });
E.btnPulse.addEventListener('click', ()=>{ if(!started) return; recordWithPulse(); });
E.btnTestBeep.addEventListener('click', ()=>{ if(!started) return; emitPulse(); });
E.btnReset.addEventListener('click', ()=>{ captured=new Float32Array(0); t1Index=t2Index=null; setFullView(); drawWave(); updateAll(); });
E.btnAuto.addEventListener('click', autoDetect);
E.btnZoomReset.addEventListener('click', ()=>{ setFullView(); drawWave(); });
E.btnApplyT1.addEventListener('click', ()=>{ const ms=parseFloat(E.t1ms.value); setMarkerMs('t1', ms); });
E.btnApplyT2.addEventListener('click', ()=>{ const ms=parseFloat(E.t2ms.value); setMarkerMs('t2', ms); });
E.btnPng.addEventListener('click', ()=>{ const a=document.createElement('a'); a.download='waveform.png'; a.href=E.wave.toDataURL('image/png'); a.click(); });
E.btnCsv.addEventListener('click', ()=>{
  const dt = (t1Index!=null && t2Index!=null) ? Math.abs(t2Index - t1Index)/sampleRate : NaN;
  const D = Number(E.dist.value);
  const v = (Number.isFinite(dt)&&dt>0&&D>0) ? (2*D/dt) : NaN;
  let csv='sample_rate,threshold,min_gap_ms,pulse_ms,pulse_type,low_cut,high_cut,out_level,window_ms¥¥n';
  csv += [sampleRate, E.thresh.value, E.minGapMs.value, E.pulseMs.value, E.pulseType.value, E.noiseLow.value, E.noiseHigh.value, E.outLevel.value, E.windowMs.value].join(',')+'¥¥n¥¥n';
  csv += 't1_ms,t2_ms,dt_ms,dist_m,v_measured_mps¥¥n';
  const t1ms = (t1Index!=null)?msOf(t1Index).toFixed(3):'';
  const t2ms = (t2Index!=null)?msOf(t2Index).toFixed(3):'';
  csv += [t1ms, t2ms, (Number.isFinite(dt)?(dt*1000).toFixed(3):''), D, (Number.isFinite(v)?v.toFixed(2):'')].join(',')+'¥¥n';
  const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.download='sound_speed_ultrashort_stable.csv'; a.href=URL.createObjectURL(blob); a.click();
});
E.btnPlay.addEventListener('click', ()=>{ const rate=parseFloat(E.playRate.value)||1; playCaptured(rate); });
window.addEventListener('resize', ()=>{ drawWave(); });

function init(){ resizeCanvasForDPR(); drawWave(); refreshDevices(); updateHintsAndAuto(); }
init();
</script>
</body>
</html>
