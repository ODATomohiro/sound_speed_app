<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>音速測定（Audiomass風・ms表記／固定ホワイトノイズ統合）</title>
<style>
*{box-sizing:border-box}html,body{margin:0;padding:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,'Hiragino Kaku Gothic ProN','Noto Sans JP','Meiryo',sans-serif;color:#111}
header{padding:18px 16px;background:linear-gradient(90deg,#eef2ff,#fff)}h1{margin:0;font-size:22px}p.sub{margin:4px 0 0;color:#555}
main{max-width:1180px;margin:18px auto;padding:0 12px}
.card{background:#fff;border:1px solid #e5e7eb;border-radius:16px;padding:14px 14px 10px;margin:14px 0;box-shadow:0 1px 2px rgba(0,0,0,0.05)}
h2{margin:0 0 10px;font-size:18px}
.controls{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0 2px}
button{appearance:none;border:1px solid #cbd5e1;background:#0ea5e9;color:#fff;padding:9px 12px;border-radius:10px;cursor:pointer;font-weight:700}
button.secondary{background:#fff;color:#111;border-color:#cbd5e1}
button.ghost{background:#fff;color:#0f172a;border-color:#e5e7eb}
button:disabled{opacity:.55;cursor:not-allowed;background:#9ca3af;border-color:#9ca3af}
select{padding:8px;border:1px solid #d1d5db;border-radius:10px;background:#fff;max-width:100%}
label{display:flex;flex-direction:column;gap:6px;font-size:14px}
input[type=number], input[type=text]{padding:8px;border:1px solid #d1d5db;border-radius:10px}
input[type=range]{width:100%}
.small{font-size:12px;color:#475569}
.status{font-size:12px;color:#334155;background:#f1f5f9;border:1px solid #e2e8f0;border-radius:10px;padding:6px 10px;display:flex;flex-wrap:wrap;gap:10px;align-items:center}
.badge{display:inline-flex;align-items:center;gap:6px;background:#e2e8f0;border:1px solid #cbd5e1;border-radius:999px;padding:3px 8px}
.canvas-wrap{position:relative}
canvas{background:#0b1020;border-radius:14px;max-width:100%;height:auto;border:1px solid #1f2937;touch-action:none}
.legend{display:flex;flex-wrap:wrap;gap:10px;font-size:12px;margin-top:6px;align-items:center}
.legend .help{color:#475569}
.toolbar{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
.toolbar button{padding:6px 10px;border-radius:8px}
.rulerTooltip{position:absolute;top:4px;right:8px;background:rgba(255,255,255,.9);color:#0f172a;border:1px solid #cbd5e1;border-radius:8px;padding:2px 8px;font-size:12px;pointer-events:none}
.selReadout{font-weight:700}
.results{display:flex;gap:16px;flex-wrap:wrap;padding:8px 0;font-weight:600}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;background:#0b1020;color:#e2e8f0;border-radius:12px;padding:10px;white-space:pre-wrap;line-height:1.35}
@media (max-width:820px){.grid.two{grid-template-columns:1fr}.grid.three{grid-template-columns:1fr;}.grid.four{grid-template-columns:1fr 1fr}}
.grid.two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid.three{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
.grid.four{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px}
.inlineRow{display:flex;flex-direction:row;align-items:center;gap:8px}
</style>
</head>
<body>
  <header>
    <h1>音速測定（Audiomass風・ms表記／固定ホワイトノイズ統合）</h1>
    <p class="sub">超短パルス（最短 0.02 ms）・固定ホワイトノイズ（決定論）・上部ルーラー（ms）・選択→t1/t2・ズーム。</p>
  </header>

  <main>
    <section class="card">
      <h2>1. デバイス</h2>
      <div class="status" id="devStatus"><span class="badge">未初期化</span></div>
      <div style="display:grid;grid-template-columns:1.2fr 1.2fr auto;gap:10px;margin-top:10px">
        <label>マイク（入力）
          <select id="micSelect"><option>（許可後に取得）</option></select>
        </label>
        <label>スピーカー（出力）
          <select id="spkSelect"><option>（対応ブラウザのみ）</option></select>
          <span class="small" id="spkNote"></span>
        </label>
        <div class="controls">
          <button id="btnStart">① マイク開始</button>
          <button id="btnRefresh">再検出</button>
        </div>
      </div>
    </section>

    <section class="card">
      <h2>2. 発音（超短パルス）</h2>
      <div class="grid four">
        <label>発音タイプ
          <select id="pulseType">
            <option value="impulse" selected>クリック（超短パルス）</option>
            <option value="white">ホワイトノイズ（短）</option>
            <option value="chirp">チャープ（短）</option>
          </select>
        </label>
        <label>パルス長（ms, 0.02–5.00）
          <input id="pulseMs" type="range" min="0.02" max="5.00" step="0.01" value="0.80">
          <span id="pulseVal">0.80</span>
        </label>
        <label>帯域（低域カットHz）<input id="noiseLow" type="number" min="20" max="10000" step="10" value="500"></label>
        <label>帯域（高域カットHz）<input id="noiseHigh" type="number" min="1000" max="20000" step="100" value="8000"></label>
      </div>
      <div class="grid two">
        <label class="inlineRow"><input id="fixedNoise" type="checkbox"> 固定ホワイトノイズ（毎回同じ乱数列）
          <button id="btnReseed" class="ghost" title="乱数列を更新">ランダマイズ</button>
        </label>
        <label>録音窓(ms)
          <input id="windowMs" type="range" min="50" max="1000" step="10" value="120">
          <span id="windowVal">120</span>
        </label>
      </div>
      <div class="grid two">
        <label>出力レベル（スピーカー）
          <input id="outLevel" type="range" min="0.05" max="1.0" step="0.01" value="0.8">
          <span id="outLevelVal">0.80</span>
        </label>
        <div class="small">※ クリック/ホワイトは短いノイズに窓掛け＋HPF/LPF。固定ONで決定論的になります（チャープには無関係）。</div>
      </div>
      <div class="controls">
        <button id="btnPulse" disabled>② 発音 + 記録</button>
        <button id="btnTestBeep" disabled>発音テストのみ</button>
        <button id="btnReset" class="secondary">リセット</button>
      </div>
    </section>

    <section class="card">
      <h2>3. 目安と自動設定</h2>
      <div class="grid three">
        <label>管の長さ D（m）<input id="dist" type="number" step="0.01" value="0.50"></label>
        <div class="badge">往復遅延 目安：<span id="dtHint">—</span> ms（c≈343 m/s）</div>
        <label style="align-self:end;flex-direction:row;gap:8px;align-items:center;">
          <input id="autoGap" type="checkbox" checked> D から最小遅延を自動設定（0.8×往復遅延）
        </label>
      </div>
      <div class="grid three">
        <label>最小遅延(ms)
          <input id="minGapMs" type="range" min="0.1" max="50" step="0.1" value="2.5">
          <span id="minGapVal">2.5</span>
        </label>
        <label>しきい値（自動検出）
          <input id="thresh" type="range" min="0.02" max="0.6" step="0.01" value="0.12">
          <span id="threshVal">0.12</span>
        </label>
        <div class="controls" style="align-items:end">
          <button id="btnApplySuggested" class="secondary">推奨値をセット</button>
          <button id="btnAuto" disabled>自動検出</button>
        </div>
      </div>
    </section>

    <section class="card">
      <h2>4. 波形（Audiomass風ルーラー＆選択）</h2>
      <div class="canvas-wrap" style="position:relative">
        <div id="rulerTip" class="rulerTooltip" style="display:none">0.00 ms</div>
        <canvas id="wave" width="1400" height="520"></canvas>
      </div>
      <div class="legend">
        <div class="help">ドラッグ：<b>Shift+ドラッグで選択</b>／通常ドラッグでパン／ホイールでズーム／<kbd>R</kbd>でリセット</div>
        <div>選択: <span class="selReadout" id="selInfo">—</span></div>
      </div>
      <div class="toolbar">
        <button id="tbZoomIn" class="ghost">ズーム＋</button>
        <button id="tbZoomOut" class="ghost">ズーム−</button>
        <button id="tbZoomSel" class="ghost">選択でズーム</button>
        <button id="tbClearSel" class="ghost">選択解除</button>
        <button id="tbUseSel" class="ghost">選択→t1/t2</button>
        <button id="tbFit" class="ghost">全体表示</button>
      </div>
      <div class="grid two" style="margin-top:8px">
        <label>t1（ms）<div class="controls"><input id="t1ms" type="number" step="0.01" placeholder="例: 1.2"><button id="btnApplyT1">t1に適用</button></div></label>
        <label>t2（ms）<div class="controls"><input id="t2ms" type="number" step="0.01" placeholder="例: 4.0"><button id="btnApplyT2">t2に適用</button></div></label>
      </div>
      <div class="controls">
        <button id="btnClearMarks" disabled>マーク削除</button>
        <button id="btnZoomReset" class="secondary">ズームリセット</button>
        <button id="btnPng" disabled>PNG保存</button>
      </div>
    </section>

    <section class="card">
      <h2>5. 計算（v = 2D / Δt）</h2>
      <div class="results">
        <div>t1 = <span id="t1Val">–</span> ms</div>
        <div>t2 = <span id="t2Val">–</span> ms</div>
        <div>Δt = <span id="dtVal">–</span> ms</div>
        <div>v = <span id="vMeasured">–</span> m/s</div>
      </div>
      <div class="controls">
        <button id="btnCompute" disabled>計算</button>
        <button id="btnCsv" disabled>CSV出力</button>
        <select id="playRate">
          <option value="1">1×</option>
          <option value="0.5">0.5×</option>
          <option value="0.25">0.25×（聞き分け用）</option>
        </select>
        <button id="btnPlay" disabled>録音波形を再生</button>
      </div>
    </section>
  </main>

<script>
// ===== Core =====
const C = 343;
const E = (id)=>document.getElementById(id);
const els = {
  devStatus:E('devStatus'), micSelect:E('micSelect'), spkSelect:E('spkSelect'), spkNote:E('spkNote'),
  btnStart:E('btnStart'), btnRefresh:E('btnRefresh'),
  pulseType:E('pulseType'), pulseMs:E('pulseMs'), pulseVal:E('pulseVal'),
  noiseLow:E('noiseLow'), noiseHigh:E('noiseHigh'),
  fixedNoise:E('fixedNoise'), btnReseed:E('btnReseed'),
  outLevel:E('outLevel'), outLevelVal:E('outLevelVal'),
  windowMs:E('windowMs'), windowVal:E('windowVal'),
  btnPulse:E('btnPulse'), btnTestBeep:E('btnTestBeep'), btnReset:E('btnReset'),
  dist:E('dist'), dtHint:E('dtHint'), autoGap:E('autoGap'),
  minGapMs:E('minGapMs'), minGapVal:E('minGapVal'), thresh:E('thresh'), threshVal:E('threshVal'),
  btnApplySuggested:E('btnApplySuggested'), btnAuto:E('btnAuto'),
  wave:E('wave'), rulerTip:E('rulerTip'), selInfo:E('selInfo'),
  tbZoomIn:E('tbZoomIn'), tbZoomOut:E('tbZoomOut'), tbZoomSel:E('tbZoomSel'),
  tbClearSel:E('tbClearSel'), tbUseSel:E('tbUseSel'), tbFit:E('tbFit'),
  t1ms:E('t1ms'), t2ms:E('t2ms'), btnApplyT1:E('btnApplyT1'), btnApplyT2:E('btnApplyT2'),
  btnClearMarks:E('btnClearMarks'), btnZoomReset:E('btnZoomReset'), btnPng:E('btnPng'),
  t1Val:E('t1Val'), t2Val:E('t2Val'), dtVal:E('dtVal'), vMeasured:E('vMeasured'),
  btnCompute:E('btnCompute'), btnCsv:E('btnCsv'), playRate:E('playRate'), btnPlay:E('btnPlay'),
};
function bindRange(input, outSpan, fmt=(v)=>v){ const update=()=>outSpan.textContent=fmt(Number(input.value)); input.addEventListener('input', update); update(); }
bindRange(els.pulseMs, els.pulseVal, v=>v.toFixed(2));
bindRange(els.outLevel, els.outLevelVal, v=>v.toFixed(2));
bindRange(els.windowMs, els.windowVal, v=>v.toFixed(0));
bindRange(els.minGapMs, els.minGapVal, v=>v.toFixed(1));
bindRange(els.thresh, els.threshVal, v=>v.toFixed(2));

let audioCtx=null, sampleRate=48000;
let micStream=null, micNode=null, scriptNode=null, outGain=null, outAudio=null;
let started=false;
let captured=new Float32Array(0), capturing=false;
let viewStart=0, viewEnd=0;
let t1Index=null, t2Index=null, lastActive='t2';
let seed = 123456789; // for fixed noise

// Selection
let selStartIdx=null, selEndIdx=null;
function clearSelection(){ selStartIdx=selEndIdx=null; updateSelInfo(); drawWave(); }
function updateSelInfo(){
  if(selStartIdx==null||selEndIdx==null){ els.selInfo.textContent='—'; return; }
  const s=Math.min(selStartIdx, selEndIdx), e=Math.max(selStartIdx, selEndIdx);
  const sMs = msOf(s).toFixed(2), eMs=msOf(e).toFixed(2), dMs=msOf(e-s).toFixed(2);
  els.selInfo.textContent = `${sMs} – ${eMs}  (Δ ${dMs} ms)`;
}

function enableAfterStart(on){
  [els.btnPulse, els.btnTestBeep, els.btnAuto, els.btnClearMarks, els.btnPng, els.btnCompute, els.btnCsv, els.btnPlay].forEach(b=>b.disabled=!on);
}

function setStatus({mics=0, spks=0, note=''}){
  els.devStatus.innerHTML = `<span class="badge">入力:${mics}</span><span class="badge">出力:${spks}</span>${note?`<span class="badge">${note}</span>`:''}`;
}

async function refreshDevices(){
  try{ const tmp=await navigator.mediaDevices.getUserMedia({audio:true}); tmp.getTracks().forEach(t=>t.stop()); }catch{}
  const devs = await navigator.mediaDevices.enumerateDevices();
  const mics=devs.filter(d=>d.kind==='audioinput'); const spks=devs.filter(d=>d.kind==='audiooutput');
  const prevMic=els.micSelect.value, prevSpk=els.spkSelect.value;
  els.micSelect.innerHTML=''; mics.forEach(d=>{ const o=document.createElement('option'); o.value=d.deviceId; o.textContent=d.label||`マイク (${d.deviceId.slice(0,6)})`; els.micSelect.appendChild(o); });
  els.spkSelect.innerHTML=''; if(spks.length){ spks.forEach(d=>{ const o=document.createElement('option'); o.value=d.deviceId; o.textContent=d.label||`スピーカー (${d.deviceId.slice(0,6)})`; els.spkSelect.appendChild(o); }); } else { const o=document.createElement('option'); o.textContent='（出力選択 未対応）'; els.spkSelect.appendChild(o); }
  if ([...els.micSelect.options].some(o=>o.value===prevMic)) els.micSelect.value=prevMic;
  if ([...els.spkSelect.options].some(o=>o.value===prevSpk)) els.spkSelect.value=prevSpk;
  setStatus({mics:mics.length, spks:spks.length, note:'再検出'});
}

async function ensureAudio(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)(); await audioCtx.resume(); sampleRate=audioCtx.sampleRate;
  outGain = audioCtx.createGain(); outGain.gain.value=Number(els.outLevel.value);
  outGain.connect(audioCtx.destination);
  if ('setSinkId' in HTMLMediaElement.prototype){
    outAudio = new Audio(); outAudio.autoplay=true; els.spkNote.textContent='出力切替 対応';
    const dest = audioCtx.createMediaStreamDestination(); outGain.disconnect(); outGain.connect(dest); outAudio.srcObject = dest.stream;
    outAudio.play().catch(()=>{});
    els.spkSelect.addEventListener('change', async ()=>{ const id=els.spkSelect.value; if(id){ try{ await outAudio.setSinkId(id);}catch(e){ console.warn('setSinkId failed', e); } } });
  } else { els.spkNote.textContent='出力切替 非対応'; }
  els.outLevel.addEventListener('input', ()=>{ if(outGain) outGain.gain.value=Number(els.outLevel.value); });
}

async function startMic(){
  await ensureAudio();
  await refreshDevices();
  const micId=els.micSelect.value;
  micStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: micId?{exact:micId}:undefined, echoCancellation:false, noiseSuppression:false, autoGainControl:false, channelCount:1 } });
  micNode = audioCtx.createMediaStreamSource(micStream);
  scriptNode = audioCtx.createScriptProcessor(1024,1,1);
  scriptNode.onaudioprocess=(ev)=>{ if(!capturing) return; const input=ev.inputBuffer.getChannelData(0); const c=new Float32Array(input.length); c.set(input); const merged=new Float32Array(captured.length+c.length); merged.set(captured,0); merged.set(c,captured.length); captured=merged; };
  micNode.connect(scriptNode); scriptNode.connect(audioCtx.destination);
  started=true; enableAfterStart(true);
}

function seededNoise(len){
  let s = seed>>>0;
  const out = new Float32Array(len);
  for(let i=0;i<len;i++){
    s = (s*1664525 + 1013904223) >>> 0;
    out[i] = (s/0xFFFFFFFF)*2 - 1;
  }
  // keep last state? we want same for same len & seed each time; leave seed unchanged unless re-seeded
  return out;
}

function emitPulse(){
  const type=els.pulseType.value, ms=Number(els.pulseMs.value)||0.8;
  const low=Math.max(20, Number(els.noiseLow.value)||500);
  const high=Math.max(low+100, Number(els.noiseHigh.value)||8000);
  const len=Math.max(1, Math.round(sampleRate*(ms/1000)));
  const buf=audioCtx.createBuffer(1,len,sampleRate); const d=buf.getChannelData(0);
  if (type==='impulse' || type==='white'){
    const useFixed = els.fixedNoise.checked;
    const srcNoise = useFixed ? seededNoise(len) : null;
    for (let i=0;i<len;i++){ d[i] = useFixed ? srcNoise[i] : (Math.random()*2-1); }
  } else {
    const f0=low, f1=Math.min(high, Math.max(low*16, 6000));
    const T=len/sampleRate; for (let i=0;i<len;i++){ const t=i/sampleRate; const k=Math.log(f1/f0)/T; const ph=2*Math.PI*f0*(Math.exp(k*t)-1)/k; d[i]=Math.sin(ph); }
  }
  // window
  for (let i=0;i<len;i++){ const t=i/(len-1 || 1); const w=Math.sin(Math.PI*t)**2; d[i]*=w; }
  // filters
  const src = audioCtx.createBufferSource(); src.buffer=buf;
  const hpf=audioCtx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=low; hpf.Q.value=0.707;
  const lpf=audioCtx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=high; lpf.Q.value=0.707;
  src.connect(hpf).connect(lpf).connect(outGain);
  src.start();
}

els.btnReseed.addEventListener('click', ()=>{ seed = (Math.random()*0xFFFFFFFF)>>>0; els.btnReseed.textContent='ランダマイズ済'; setTimeout(()=>els.btnReseed.textContent='ランダマイズ', 900); });

function recordWithPulse(){
  captured=new Float32Array(0); t1Index=t2Index=null; clearSelection(); updateAll();
  const autoWin = Math.min(1000, Math.max(50, Math.round((2*Number(els.dist.value||0.5)/C)*1000 * 3 + 50)));
  const windowMs = Number(els.windowMs.value)||autoWin;
  capturing=true; emitPulse();
  setTimeout(()=>{ capturing=false; setFullView(); drawWave(); }, windowMs);
}

function playCaptured(rate=1){
  if(!captured.length || !audioCtx) return;
  const buf=audioCtx.createBuffer(1,captured.length,sampleRate); buf.copyToChannel(captured,0,0);
  const src=audioCtx.createBufferSource(); src.buffer=buf; src.playbackRate.value=rate;
  const g=audioCtx.createGain(); g.gain.value=0.6; src.connect(g).connect(outGain); src.start();
}

// ===== Waveform & Ruler =====
const ctx = els.wave.getContext('2d');
function resizeCanvasForDPR(){ const rect=els.wave.getBoundingClientRect(); const dpr=window.devicePixelRatio||1; const needW=Math.max(1,Math.floor(rect.width*dpr)); const needH=Math.max(1,Math.floor(rect.height*dpr)); if(els.wave.width!==needW||els.wave.height!==needH){ els.wave.width=needW; els.wave.height=needH; } ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr,dpr); }
function setFullView(){ viewStart=0; viewEnd=captured.length; }
function clampView(){ const len=captured.length, minW=Math.max(128, Math.floor(sampleRate*0.001)); if(viewStart<0) viewStart=0; if(viewEnd>len) viewEnd=len; if(viewEnd-viewStart<minW){ const mid=(viewStart+viewEnd)/2; viewStart=Math.max(0,Math.floor(mid-minW/2)); viewEnd=Math.min(len,viewStart+minW); } }
function msOf(i){ return (i/sampleRate)*1000; }
function idxAtMs(ms){ return Math.round(ms/1000*sampleRate); }
function xToIdxCss(xCss){ const W=els.wave.getBoundingClientRect().width||1; const span=(viewEnd-viewStart)||1; const frac=Math.max(0,Math.min(1,xCss/W)); return Math.round(viewStart+frac*span); }
function idxToXCss(idx){ const W=els.wave.getBoundingClientRect().width||1; const span=(viewEnd-viewStart)||1; return Math.round((idx-viewStart)*W/span); }
function niceStepMs(spanMs){ const bases=[1,2,5]; let pow = Math.pow(10, Math.floor(Math.log10(spanMs/8))); for(let i=0;i<12;i++){ for(const b of bases){ const step=b*pow; const majors = spanMs/step; if(majors<=12) return step; } pow*=10; } return spanMs/10; }
function drawRuler(W,H,rH,startMs,endMs){
  const spanMs=endMs-startMs;
  const step=niceStepMs(spanMs);
  const minor = step/5;
  const grd = ctx.createLinearGradient(0,0,0,rH);
  grd.addColorStop(0,'#e2e8f0'); grd.addColorStop(1,'#f8fafc');
  ctx.fillStyle=grd; ctx.fillRect(0,0,W,rH);
  ctx.strokeStyle='#94a3b8'; ctx.strokeRect(0,0,W,rH);

  ctx.strokeStyle='#cbd5e1'; ctx.lineWidth=1;
  let t = Math.ceil(startMs/minor)*minor;
  for(; t<=endMs+1e-6; t+=minor){
    const idx=idxAtMs(t), x=idxToXCss(idx);
    const isMajor = Math.abs((t/step) - Math.round(t/step)) < 1e-6;
    if(isMajor) continue;
    ctx.beginPath(); ctx.moveTo(x, rH*0.55); ctx.lineTo(x, rH); ctx.stroke();
  }
  ctx.strokeStyle='#94a3b8'; ctx.fillStyle='#334155'; ctx.font='12px system-ui';
  t = Math.ceil(startMs/step)*step;
  for(; t<=endMs+1e-6; t+=step){
    const idx=idxAtMs(t), x=idxToXCss(idx);
    ctx.beginPath(); ctx.moveTo(x, rH*0.35); ctx.lineTo(x, rH); ctx.stroke();
    ctx.fillText(`${t.toFixed(t<1?2:(t<10?1:0))} ms`, x+3, rH-6);
  }
}

function maxAbs(i0,i1){ let m=0; for(let i=i0;i<i1;i++){ const a=Math.abs(captured[i]||0); if(a>m)m=a; } return m; }

function drawWave(){
  resizeCanvasForDPR();
  const rect=els.wave.getBoundingClientRect(); const W=rect.width, H=rect.height;
  ctx.clearRect(0,0,W,H);
  const rH = 28; // ruler height
  const usableH=H-rH-10;
  const startMs=msOf(viewStart), endMs=msOf(viewEnd);
  drawRuler(W,H,rH,startMs,endMs);

  ctx.fillStyle='#0b1020'; ctx.fillRect(0,rH,W,usableH+10);
  ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1;
  for(let y=rH; y<=H; y+=50){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.strokeStyle='rgba(255,255,255,0.18)'; ctx.beginPath(); ctx.moveTo(0,rH+usableH/2); ctx.lineTo(W,rH+usableH/2); ctx.stroke();

  if(!captured.length){ ctx.fillStyle='rgba(255,255,255,0.75)'; ctx.font='14px system-ui'; ctx.fillText('②で記録するとここに波形が表示されます',16,rH+24); return; }

  const s=viewStart,e=viewEnd,span=Math.max(1,e-s);
  const gain = (usableH*0.46)/Math.max(1e-6, maxAbs(s,e));
  ctx.strokeStyle='#7dd3fc'; ctx.lineWidth=1.3; ctx.beginPath();
  for(let x=0;x<W;x++){
    const i0=Math.floor(s+span*x/W), i1=Math.floor(s+span*(x+1)/W);
    let lo=1e9,hi=-1e9;
    for(let i=i0;i<i1;i++){ const v=captured[i]||0; if(v<lo)lo=v; if(v>hi)hi=v; }
    if(lo===1e9){lo=0;hi=0;}
    const yLo=rH+usableH/2 - lo*gain, yHi=rH+usableH/2 - hi*gain;
    ctx.moveTo(x,yLo); ctx.lineTo(x,yHi);
  }
  ctx.stroke();

  // selection overlay
  if(selStartIdx!=null && selEndIdx!=null){
    const xs=idxToXCss(Math.min(selStartIdx, selEndIdx));
    const xe=idxToXCss(Math.max(selStartIdx, selEndIdx));
    ctx.fillStyle='rgba(34,197,94,0.18)'; ctx.fillRect(xs, rH, (xe-xs), usableH);
    ctx.strokeStyle='rgba(34,197,94,0.9)'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(xs, rH); ctx.lineTo(xs, rH+usableH); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xe, rH); ctx.lineTo(xe, rH+usableH); ctx.stroke();
  }

  // markers t1/t2
  drawMarker(t1Index,'#22c55e','t1'); drawMarker(t2Index,'#f97316','t2');
  function drawMarker(idx,color,label){
    if(idx==null) return; if(idx<viewStart||idx>viewEnd) return;
    const x=idxToXCss(idx);
    ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x,rH); ctx.lineTo(x,H); ctx.stroke();
    const ms=msOf(idx).toFixed(2); ctx.fillStyle=color; ctx.font='12px system-ui'; ctx.fillText(`${label}:${ms} ms`, x+4, rH+14);
  }
}

// ===== Interactions =====
let dragState=null;
function clientXToCanvasCssX(x){ const r=els.wave.getBoundingClientRect(); return x - r.left; }
els.wave.addEventListener('mousedown', (ev)=>{
  if(!captured.length) return;
  const xCss=clientXToCanvasCssX(ev.clientX);
  const tol=6;
  const near=(()=>{ if(t1Index!=null && Math.abs(xCss-idxToXCss(t1Index))<=tol) return 't1'; if(t2Index!=null && Math.abs(xCss-idxToXCss(t2Index))<=tol) return 't2'; return null; })();
  if(near){ dragState={type:'marker',target:near}; lastActive=near; return; }
  if (ev.shiftKey){ dragState={type:'select',startX:xCss}; return; }
  dragState={type:'pan',startX:xCss,startViewStart:viewStart,startViewEnd:viewEnd};
});
window.addEventListener('mousemove', (ev)=>{
  if(!captured.length) return;
  const xCss=clientXToCanvasCssX(ev.clientX);
  // tooltip
  const idx=xToIdxCss(xCss); const ms=msOf(idx).toFixed(2);
  els.rulerTip.style.display='block'; els.rulerTip.textContent=`${ms} ms`; els.rulerTip.style.left=(xCss+10)+'px';

  if(!dragState) return;
  if(dragState.type==='marker'){
    const idx=xToIdxCss(xCss); if(dragState.target==='t1') t1Index=idx; else t2Index=idx; drawWave(); updateAll(); return;
  }
  if(dragState.type==='select'){
    selStartIdx = xToIdxCss(dragState.startX);
    selEndIdx   = xToIdxCss(xCss);
    updateSelInfo(); drawWave(); return;
  }
  // pan
  const dx=xCss-dragState.startX; const W=els.wave.getBoundingClientRect().width||1; const span=dragState.startViewEnd-dragState.startViewStart; const shift=Math.round(-dx*span/W);
  viewStart=dragState.startViewStart+shift; viewEnd=dragState.startViewEnd+shift; clampView(); drawWave();
});
window.addEventListener('mouseup', ()=>{ dragState=null; });
els.wave.addEventListener('mouseleave', ()=>{ els.rulerTip.style.display='none'; });
els.wave.addEventListener('wheel', (ev)=>{
  if(!captured.length) return; ev.preventDefault();
  const xCss=clientXToCanvasCssX(ev.clientX);
  const center=xToIdxCss(xCss); const factor=Math.exp(-ev.deltaY*0.0015); const span=viewEnd-viewStart;
  let newSpan=Math.max(Math.floor(span/factor), Math.floor(sampleRate*0.001)); const leftFrac=(center-viewStart)/span;
  viewStart=Math.round(center-newSpan*leftFrac); viewEnd=viewStart+newSpan; clampView(); drawWave();
},{passive:false});
window.addEventListener('keydown', (ev)=>{
  if(!captured.length) return;
  const step=ev.shiftKey?10:1;
  if(ev.key==='ArrowLeft'){ if(lastActive==='t2'&&t2Index!=null) t2Index=Math.max(0,t2Index-step); else if(t1Index!=null) t1Index=Math.max(0,t1Index-step); drawWave(); updateAll(); }
  else if(ev.key==='ArrowRight'){ if(lastActive==='t2'&&t2Index!=null) t2Index=Math.min(captured.length-1,t2Index+step); else if(t1Index!=null) t1Index=Math.min(captured.length-1,t1Index+step); drawWave(); updateAll(); }
  else if(ev.key==='r'||ev.key==='R'){ setFullView(); drawWave(); }
});

// Toolbar actions
els.tbZoomIn.addEventListener('click', ()=>{ const span=viewEnd-viewStart; const center=Math.round((viewStart+viewEnd)/2); const newSpan=Math.max(Math.floor(span/1.6), Math.floor(sampleRate*0.001)); viewStart=center-Math.floor(newSpan/2); viewEnd=viewStart+newSpan; clampView(); drawWave(); });
els.tbZoomOut.addEventListener('click', ()=>{ const span=viewEnd-viewStart; const center=Math.round((viewStart+viewEnd)/2); const newSpan=Math.min(captured.length, Math.floor(span*1.6)); viewStart=center-Math.floor(newSpan/2); viewEnd=viewStart+newSpan; clampView(); drawWave(); });
els.tbZoomSel.addEventListener('click', ()=>{ if(selStartIdx==null||selEndIdx==null) return; viewStart=Math.min(selStartIdx, selEndIdx); viewEnd=Math.max(selStartIdx, selEndIdx); clampView(); drawWave(); });
els.tbClearSel.addEventListener('click', ()=>{ clearSelection(); });
els.tbUseSel.addEventListener('click', ()=>{ if(selStartIdx==null||selEndIdx==null) return; t1Index=Math.min(selStartIdx, selEndIdx); t2Index=Math.max(selStartIdx, selEndIdx); lastActive='t2'; updateAll(); drawWave(); });
els.tbFit.addEventListener('click', ()=>{ setFullView(); drawWave(); });

// Auto hints, compute etc.
function updateHintsAndAuto(){
  const D = Number(els.dist.value);
  if (!Number.isFinite(D) || D<=0){ els.dtHint.textContent='—'; return; }
  const dt = (2*D/C)*1000;
  els.dtHint.textContent = dt.toFixed(2);
  if (els.autoGap.checked){
    const mg = Math.max(0.1, dt*0.8);
    els.minGapMs.value = mg.toFixed(1);
    els.minGapVal.textContent = mg.toFixed(1);
  }
}
function updateAll(){
  const ms1 = (t1Index!=null) ? (msOf(t1Index).toFixed(2)) : '–';
  const ms2 = (t2Index!=null) ? (msOf(t2Index).toFixed(2)) : '–';
  els.t1Val.textContent = ms1; els.t2Val.textContent = ms2;
  if(t1Index==null || t2Index==null){ els.dtVal.textContent='–'; els.vMeasured.textContent='–'; return; }
  const dt = Math.abs(t2Index - t1Index) / sampleRate;
  els.dtVal.textContent = (dt*1000).toFixed(2);
  const D = Number(els.dist.value);
  els.vMeasured.textContent = (D>0 && dt>0) ? (2*D/dt).toFixed(2) : '–';
}

function setMarkerMs(which, ms){
  if (!captured.length || !Number.isFinite(ms)) return;
  const idx = Math.max(0, Math.min(captured.length-1, Math.round(ms/1000 * sampleRate)));
  if (which==='t1'){ t1Index = idx; lastActive='t1'; }
  else { t2Index = idx; lastActive='t2'; }
  const s=Math.min(t1Index,t2Index), e=Math.max(t1Index,t2Index); const pad=Math.round((e-s)*0.6)+Math.round(sampleRate*0.005); viewStart=Math.max(0,s-pad); viewEnd=Math.min(captured.length,e+pad); clampView(); drawWave(); updateAll();
}

// Detect
function envelope(data){ const N=data.length; const abs=new Float32Array(N); for(let i=0;i<N;i++) abs[i]=Math.abs(data[i]); const win=Math.max(8, Math.round(sampleRate*0.0006)); const env=new Float32Array(N); let sum=0; for(let i=0;i<N;i++){ sum+=abs[i]; if(i>=win) sum-=abs[i-win]; env[i]=sum/Math.min(i+1,win); } return env; }
function refinePeakNear(arr, idx, radius){ const N=arr.length; let best=idx, val=arr[idx]||0; for(let i=Math.max(0,idx-radius); i<=Math.min(N-1,idx+radius); i++){ if(arr[i]>val){ val=arr[i]; best=i; } } return best; }
function autoDetect(){
  if(!captured.length) return;
  const thresh=Number(els.thresh.value), minGapMs=Number(els.minGapMs.value), minGapSamples=Math.round(sampleRate*(minGapMs/1000));
  const N=captured.length; const env=envelope(captured);
  let t1=null; for(let i=0;i<N;i++){ if(env[i]>thresh){ t1=i; break; } }
  if(t1===null){ alert('t1が検出できません'); return; }
  let t2=null; for(let i=t1+minGapSamples;i<N;i++){ if(env[i]>thresh){ t2=i; break; } }
  if(t2===null){ alert('t2が検出できません'); return; }
  t1Index=t1; t2Index=refinePeakNear(env,t2,Math.round(sampleRate*0.0015));
  const s=Math.min(t1Index,t2Index), e=Math.max(t1Index,t2Index); const pad=Math.round((e-s)*0.6)+Math.round(sampleRate*0.005); viewStart=Math.max(0,s-pad); viewEnd=Math.min(captured.length,e+pad); clampView(); drawWave(); updateAll();
}

// Wire UI
els.btnStart.addEventListener('click', async ()=>{ try{ await startMic(); }catch(e){ alert('マイク開始失敗: '+e.message); } });
els.btnRefresh.addEventListener('click', async ()=>{ await refreshDevices(); });
els.btnPulse.addEventListener('click', ()=>{ if(!started) return; recordWithPulse(); });
els.btnTestBeep.addEventListener('click', ()=>{ if(!started) return; emitPulse(); });
els.btnReset.addEventListener('click', ()=>{ captured=new Float32Array(0); t1Index=t2Index=null; clearSelection(); setFullView(); drawWave(); updateAll(); });
els.btnAuto.addEventListener('click', autoDetect);
els.btnZoomReset.addEventListener('click', ()=>{ setFullView(); drawWave(); });
els.btnApplyT1.addEventListener('click', ()=>{ const ms=parseFloat(els.t1ms.value); setMarkerMs('t1', ms); });
els.btnApplyT2.addEventListener('click', ()=>{ const ms=parseFloat(els.t2ms.value); setMarkerMs('t2', ms); });
els.btnPng.addEventListener('click', ()=>{ const a=document.createElement('a'); a.download='waveform.png'; a.href=els.wave.toDataURL('image/png'); a.click(); });
els.btnCsv.addEventListener('click', ()=>{
  const dt = (t1Index!=null && t2Index!=null) ? Math.abs(t2Index - t1Index)/sampleRate : NaN;
  const D = Number(els.dist.value);
  const v = (Number.isFinite(dt)&&dt>0&&D>0) ? (2*D/dt) : NaN;
  let csv='sample_rate,threshold,min_gap_ms,pulse_ms,pulse_type,low_cut,high_cut,fixed_noise,out_level,window_ms¥¥n';
  csv += [sampleRate, els.thresh.value, els.minGapMs.value, els.pulseMs.value, els.pulseType.value, els.noiseLow.value, els.noiseHigh.value, els.fixedNoise.checked, els.outLevel.value, els.windowMs.value].join(',')+'¥¥n¥¥n';
  csv += 't1_ms,t2_ms,dt_ms,dist_m,v_measured_mps¥¥n';
  const t1ms = (t1Index!=null)?msOf(t1Index).toFixed(3):'';
  const t2ms = (t2Index!=null)?msOf(t2Index).toFixed(3):'';
  csv += [t1ms, t2ms, (Number.isFinite(dt)?(dt*1000).toFixed(3):''), D, (Number.isFinite(v)?v.toFixed(2):'')].join(',')+'¥¥n';
  const blob=new Blob([csv],{type:'text/csv'}); const a=document.createElement('a'); a.download='sound_speed_audiomass_ms_integrated.csv'; a.href=URL.createObjectURL(blob); a.click();
});
els.playRate.addEventListener('change', ()=>{});
els.btnPlay.addEventListener('click', ()=>{ const rate=parseFloat(els.playRate.value)||1; playCaptured(rate); });

// Hints & init
els.dist.addEventListener('input', ()=>{ updateHintsAndAuto(); updateAll(); });
function init(){ resizeCanvasForDPR(); drawWave(); refreshDevices(); updateHintsAndAuto(); }
window.addEventListener('resize', drawWave);
init();
</script>
</body>
</html>
